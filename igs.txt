Notes

I feel we have left the problem of worldFolds Unresolved, being how can we deal with a living nonContainer attempting to carry something.

Essentially we want different behaviour of the doAction Function based on the constraints satisfied by a given object

i.e. 

doGet :: World

Or rather, it might be better for us, given that we are separating lexer from parser. To create actions as sourced

i.e. Action = Target TokenCollection 

where Target is the source actor, with the idea that we can then check for constraint via worldFolding to find the source, failure means failure on constraint.



There is also the idea that we could totally replace IO with some sort of new layer, one which can only return tokens

This however seems a bit too grandiose as how can we deal with output

The simplest way of doing this would be to simply replace getInput with getTokens where-ever possible

What do we gain?

Well consistency, we don't need to constantly be dealing directly with strings,it also allows us to deal with conversation interestingly
We can consider saying things as Action SayT [Token] for instance This points to two things,

First we now resolve or concern over Actions having associated lists of tokens
We see here an example of the most extreme use case for an embedded token list, wherein the whole token list takes on a new level of modality.
But even here, what is gained over simply placing the list in its natural place, appending and not embedding in Say.
The main argument is one of moving more functionality to the lexer, at least insofar as we can do so without increasing its requirements
This is certainly something we can do with only syntax. 

So what was the problem

well what is the difference between Say [tokens] and Say [] toks

the only thing we might take as meaningful would be the different resultant tree structure

i.e. the first only allows for only a single interpretation whereas the second allows for subsequent lexes to produce multiple interpretations

However, this brings to light aproblem with our current lexxing, we assume that a single token can produce only a single Token, and similarly that later lexes cannot influence earlier tokens

We have been avoiding the second problem thus far by being able pre-dict all of the the possible modifications, however in order for us to continue doing this we need to be able to produce mutliple tokens from the second word.

what we need is instead of returning [(Token,[String])] we want to return [([Token],[String])] where [([],[stuff])] == [];


Ok, so we've pretty much got lexing/parsing working fine, at least structurally.
We can now go back to repairing ia.



Working on Movement, I think we might want to move away from the ghost-memory idea we had had previously

instead it might be better to revisit our action timer idea, if we simply have 

Though there is a problem here, where do we deal with the timer,

There is a couple considerations we would need to take

We need to occasionally get new input and reset the timer

we also will want to be able to trigger action at only certain intervals, i.e. moving a tile only every 5 ticks

And ideally we would have both this interval and the overall length of the timer before new input is requested vary depending on the actor.

So I'm thinking we need a function with signature  (Id,Tick,TokenCollection) -> World  -> Maybe Bool

We can then restructure our program such that we filter out any actiongroups that return nothing

Then we can filter again into two differant lists one for true, one for false,

the true list we pass to doAction

the false list we fold over, getting a new action group associated with each id

now we come to the issue of the tokenCollection

It somewhat complicates our above function, 

especially given that the whole point of preserving the tokenCollection was to preserve ambiguity & the ability to parse in multiple differant ways

So I think we are going to need to change our actiongroup to 

(Id,Tick,Intent)

Which means we need to recreate our checkIntent function Id -> Intent -> World -> Bool

